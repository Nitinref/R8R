// schema.prisma - UPDATED WITH DAG WORKFLOW MODELS

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String      @id @default(uuid())
  email         String      @unique
  password      String
  name          String?
  apiKeys       ApiKey[]
  workflows     Workflow[]
  queryLogs     QueryLog[]
  documents     Document[]
  memories      Memory[]      // NEW: Memory relation
  workflowDags  WorkflowDag[] // NEW: DAG workflows relation
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model ApiKey {
  id              String              @id @default(uuid())
  key             String              @unique
  name            String
  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  isActive        Boolean             @default(true)
  canRead         Boolean             @default(true)
  canWrite        Boolean             @default(false)
  lastUsedAt      DateTime?
  createdAt       DateTime            @default(now())
  workflows       ApiKeyWorkflow[]
  
  @@index([key])
  @@index([userId])
}

model ApiKeyWorkflow {
  id          String   @id @default(uuid())
  apiKeyId    String
  workflowId  String
  apiKey      ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)
  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  
  @@unique([apiKeyId, workflowId])
  @@index([apiKeyId])
  @@index([workflowId])
}

model Workflow {
  id              String              @id @default(uuid())
  name            String
  description     String?
  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  configuration   Json
  status          String              @default("draft")
  version         Int                 @default(1)
  vectorIndexName String?
  vectorNamespace String?
  queryLogs       QueryLog[]
  analytics       WorkflowAnalytics?
  apiKeys         ApiKeyWorkflow[]
  memories        Memory[]            // NEW: Memory relation
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  @@index([userId])
  @@index([status])
}

model Document {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workflowId      String?
  filename        String
  content         String    @db.Text
  metadata        Json      @default("{}")
  vectorIds       Json      @default("[]")
  status          String    @default("pending")
  errorMessage    String?
  chunkCount      Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([workflowId])
  @@index([status])
}

model QueryLog {
  id              String    @id @default(uuid())
  workflowId      String
  workflow        Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  query           String    @db.Text
  rewrittenQuery  String?   @db.Text
  answer          String    @db.Text
  sources         Json      @default("[]")
  confidence      Float?
  latency         Int
  llmsUsed        Json      @default("[]")
  retrieversUsed  Json      @default("[]")
  tokensUsed      Int       @default(0)
  estimatedCost   Float     @default(0)
  status          String
  errorMessage    String?   @db.Text
  metadata        Json?
  createdAt       DateTime  @default(now())
  
  @@index([workflowId])
  @@index([userId])
  @@index([createdAt])
  @@index([status])
}

model WorkflowAnalytics {
  id                    String    @id @default(uuid())
  workflowId            String    @unique
  workflow              Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  totalQueries          Int       @default(0)
  successfulQueries     Int       @default(0)
  failedQueries         Int       @default(0)
  avgLatency            Float     @default(0)
  avgConfidence         Float     @default(0)
  totalTokensUsed       Int       @default(0)
  estimatedCost         Float     @default(0)
  lastQueryAt           DateTime?
  updatedAt             DateTime  @updatedAt
}

// ==================== NEW MEMORY MODEL ====================

model Memory {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workflowId      String?
  workflow        Workflow? @relation(fields: [workflowId], references: [id], onDelete: SetNull)
  
  // Content
  query           String    @db.Text
  response        String    @db.Text
  
  // Vector embedding (stored as Float array for pgvector or as Json)
  embedding       Json      // PostgreSQL array for pgvector extension
  
  // Metadata
  importance      Float     @default(0.5)        // 0-1 score
  type            String    @default("conversation") // conversation, fact, preference, decision
  tags            String[]  @default([])         // Topic tags
  
  // Access tracking
  accessCount     Int       @default(0)
  lastAccessed    DateTime  @default(now())
  
  // Additional metadata (JSON for flexibility)
  metadata        Json      @default("{}")
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([workflowId])
  @@index([type])
  @@index([importance])
  @@index([createdAt])
  @@index([lastAccessed])
}

// ==================== DAG WORKFLOW MODELS ====================

model WorkflowDag {
  id          String   @id @default(uuid())
  name        String
  description String?
  status      WorkflowDagStatus @default(DRAFT)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  nodes       WorkflowDagNode[]
  runs        WorkflowDagRun[]
  
  @@map("workflow_dags")
  @@index([userId])
  @@index([status])
}

model WorkflowDagNode {
  id          String   @id @default(uuid())
  name        String
  type        WorkflowNodeType
  config      Json     // Node-specific configuration
  workflowId  String
  order       Int      // Execution order hint
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  workflow    WorkflowDag @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  fromEdges   WorkflowDagConnection[] @relation("WorkflowDagNodeFrom")
  toEdges     WorkflowDagConnection[] @relation("WorkflowDagNodeTo")
  runs        WorkflowDagNodeRun[]
  
  @@map("workflow_dag_nodes")
  @@index([workflowId])
}

model WorkflowDagConnection {
  id       String @id @default(uuid())
  fromId   String
  toId     String
  createdAt DateTime @default(now())
  
  fromNode WorkflowDagNode @relation("WorkflowDagNodeFrom", fields: [fromId], references: [id], onDelete: Cascade)
  toNode   WorkflowDagNode @relation("WorkflowDagNodeTo", fields: [toId], references: [id], onDelete: Cascade)
  
  @@map("workflow_dag_connections")
  @@unique([fromId, toId])
  @@index([fromId])
  @@index([toId])
}

model WorkflowDagRun {
  id          String             @id @default(uuid())
  workflowId  String
  status      WorkflowDagStatus
  startedAt   DateTime?
  finishedAt  DateTime?
  result      Json?
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  
  workflow    WorkflowDag @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  nodeRuns    WorkflowDagNodeRun[]
  
  @@map("workflow_dag_runs")
  @@index([workflowId])
  @@index([status])
}

model WorkflowDagNodeRun {
  id             String     @id @default(uuid())
  nodeId         String
  workflowRunId  String
  status         WorkflowNodeRunStatus
  startedAt      DateTime?
  finishedAt     DateTime?
  result         Json?
  error          String?
  logs           String[]
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  
  node           WorkflowDagNode       @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  workflowRun    WorkflowDagRun @relation(fields: [workflowRunId], references: [id], onDelete: Cascade)
  
  @@map("workflow_dag_node_runs")
  @@index([nodeId])
  @@index([workflowRunId])
  @@index([status])
}

enum WorkflowDagStatus {
  DRAFT
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum WorkflowNodeRunStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  SKIPPED
}

enum WorkflowNodeType {
  LLM_QUERY      // Your existing R8R query execution
  DATA_PROCESSING
  API_CALL
  CONDITIONAL    // Branching logic
  NOTIFICATION   // Telegram/slack notifications
  MEMORY_QUERY   // Query memory system
  MEMORY_STORE   // Store to memory system
  DOCUMENT_RETRIEVAL // Your existing RAG
  CUSTOM_SCRIPT
  DELAY          // Wait for specified time
  WEBHOOK        // Trigger webhook
}