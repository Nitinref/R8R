// schema.prisma - UPDATED WITH MEMORY MODEL

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String      @id @default(uuid())
  email         String      @unique
  password      String
  name          String?
  apiKeys       ApiKey[]
  workflows     Workflow[]
  queryLogs     QueryLog[]
  documents     Document[]
  memories      Memory[]      // NEW: Memory relation
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
}

model ApiKey {
  id              String              @id @default(uuid())
  key             String              @unique
  name            String
  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  isActive        Boolean             @default(true)
  canRead         Boolean             @default(true)
  canWrite        Boolean             @default(false)
  lastUsedAt      DateTime?
  createdAt       DateTime            @default(now())
  workflows       ApiKeyWorkflow[]
  
  @@index([key])
  @@index([userId])
}

model ApiKeyWorkflow {
  id          String   @id @default(uuid())
  apiKeyId    String
  workflowId  String
  apiKey      ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)
  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  
  @@unique([apiKeyId, workflowId])
  @@index([apiKeyId])
  @@index([workflowId])
}

model Workflow {
  id              String              @id @default(uuid())
  name            String
  description     String?
  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  configuration   Json
  status          String              @default("draft")
  version         Int                 @default(1)
  vectorIndexName String?
  vectorNamespace String?
  queryLogs       QueryLog[]
  analytics       WorkflowAnalytics?
  apiKeys         ApiKeyWorkflow[]
  memories        Memory[]            // NEW: Memory relation
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  @@index([userId])
  @@index([status])
}

model Document {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workflowId      String?
  filename        String
  content         String    @db.Text
  metadata        Json      @default("{}")
  vectorIds       Json      @default("[]")
  status          String    @default("pending")
  errorMessage    String?
  chunkCount      Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([workflowId])
  @@index([status])
}

model QueryLog {
  id              String    @id @default(uuid())
  workflowId      String
  workflow        Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  query           String    @db.Text
  rewrittenQuery  String?   @db.Text
  answer          String    @db.Text
  sources         Json      @default("[]")
  confidence      Float?
  latency         Int
  llmsUsed        Json      @default("[]")
  retrieversUsed  Json      @default("[]")
  tokensUsed      Int       @default(0)
  estimatedCost   Float     @default(0)
  status          String
  errorMessage    String?   @db.Text
  metadata        Json?
  createdAt       DateTime  @default(now())
  
  @@index([workflowId])
  @@index([userId])
  @@index([createdAt])
  @@index([status])
}

model WorkflowAnalytics {
  id                    String    @id @default(uuid())
  workflowId            String    @unique
  workflow              Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  totalQueries          Int       @default(0)
  successfulQueries     Int       @default(0)
  failedQueries         Int       @default(0)
  avgLatency            Float     @default(0)
  avgConfidence         Float     @default(0)
  totalTokensUsed       Int       @default(0)
  estimatedCost         Float     @default(0)
  lastQueryAt           DateTime?
  updatedAt             DateTime  @updatedAt
}

// ==================== NEW MEMORY MODEL ====================

model Memory {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workflowId      String?
  workflow        Workflow? @relation(fields: [workflowId], references: [id], onDelete: SetNull)
  
  // Content
  query           String    @db.Text
  response        String    @db.Text
  
  // Vector embedding (stored as Float array for pgvector or as Json)
  embedding       Json      // PostgreSQL array for pgvector extension
  
  // Metadata
  importance      Float     @default(0.5)        // 0-1 score
  type            String    @default("conversation") // conversation, fact, preference, decision
  tags            String[]  @default([])         // Topic tags
  
  // Access tracking
  accessCount     Int       @default(0)
  lastAccessed    DateTime  @default(now())
  
  // Additional metadata (JSON for flexibility)
  metadata        Json      @default("{}")
  
  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([workflowId])
  @@index([type])
  @@index([importance])
  @@index([createdAt])
  @@index([lastAccessed])
}